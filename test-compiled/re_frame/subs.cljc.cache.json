["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ ","~$reagent-id","~$re-frame.interop","~$console","~$re-frame.loggers","~$dispose!","^4","~$add-on-dispose!","^4","~$make-reaction","^4","~$deref?","^4","~$ratom?","^4","~$debug-enabled?","^4"],"~:excludes",["~#set",[]],"~:name","~$re-frame.subs","~:imports",null,"~:requires",["^ ","~$re-frame.db","^C","^4","^4","^6","^6","~$re-frame.utils","^D","~$re-frame.registrar","^E","~$trace","~$re-frame.trace","^G","^G"],"~:uses",["^ ","^3","^4","^5","^6","~$app-db","^C","^7","^4","^8","^4","^9","^4","~$get-handler","^E","~$first-in-vector","^D","^:","^4","^;","^4","^<","^4","~$clear-handlers","^E","~$register-handler","^E"],"~:defs",["^ ","~$cache-and-return",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/matus/www/district0x/contribution/test-compiled/re_frame/subs.cljc","~:line",44,"~:column",7,"~:end-line",44,"~:end-column",23,"~:arglists",["~#list",["~$quote",["^X",[["~$query-v","~$dynv","~$r"]]]]],"~:doc","cache the reaction r"],"^?","~$re-frame.subs/cache-and-return","~:variadic",false,"^R","test-compiled/re_frame/subs.cljc","^V",23,"~:method-params",["^X",[["^Z","^[","~$r"]]],"~:protocol-impl",null,"~:arglists-meta",["^X",[null,null]],"^T",1,"^S",44,"^U",44,"~:max-fixed-arity",3,"~:fn-var",true,"^W",["^X",["^Y",["^X",[["^Z","^[","~$r"]]]]],"^10","cache the reaction r"],"~$deref-input-signals",["^ ","^P",null,"^Q",["^ ","^R","/Users/matus/www/district0x/contribution/test-compiled/re_frame/subs.cljc","^S",126,"^T",8,"^U",126,"^V",27,"~:private",true,"^W",["^X",["^Y",["^X",[["~$signals","~$query-id"]]]]]],"^19",true,"^?","~$re-frame.subs/deref-input-signals","^12",false,"^R","test-compiled/re_frame/subs.cljc","^V",27,"^13",["^X",[["^1:","^1;"]]],"^14",null,"^15",["^X",[null,null]],"^T",1,"^S",126,"^U",126,"^16",2,"^17",true,"^W",["^X",["^Y",["^X",[["^1:","^1;"]]]]]],"~$subscribe",["^ ","^P",null,"^Q",["^ ","^R","/Users/matus/www/district0x/contribution/test-compiled/re_frame/subs.cljc","^S",69,"^T",7,"^U",69,"^V",16,"^W",["^X",["^Y",["^X",[["^Z"],["~$v","^["]]]]],"^10","Returns a Reagent/reaction which contains a computation","~:top-fn",["^ ","^12",false,"^16",2,"^13",["^X",[["^Z"],["~$v","^["]]],"^W",["^X",[["^Z"],["~$v","^["]]],"^15",["^X",[null,null]]]],"^?","~$re-frame.subs/subscribe","^12",false,"^R","test-compiled/re_frame/subs.cljc","^V",16,"^1>",["^ ","^12",false,"^16",2,"^13",["^X",[["^Z"],["~$v","^["]]],"^W",["^X",[["^Z"],["~$v","^["]]],"^15",["^X",[null,null]]],"^13",["^X",[["^Z"],["~$v","^["]]],"^14",null,"^15",["^X",[null,null]],"^T",1,"^S",69,"^U",69,"^16",2,"^17",true,"^W",["^X",[["^Z"],["~$v","^["]]],"^10","Returns a Reagent/reaction which contains a computation"],"~$reg-sub",["^ ","^P",null,"^Q",["^ ","^R","/Users/matus/www/district0x/contribution/test-compiled/re_frame/subs.cljc","^S",137,"^T",7,"^U",137,"^V",14,"^W",["^X",["^Y",["^X",[["^1;","~$&","~$args"]]]]],"^10","Associate the given `query id` with a handler function and an optional signal function.\n\n  There's 3 ways this function can be called\n\n  1. (reg-sub\n       :test-sub\n       (fn [db [_]] db))\n  The value in app-db is passed to the computation function as the 1st argument.\n\n  2. (reg-sub\n       :a-b-sub\n       (fn [q-vec d-vec]\n         [(subs/subscribe [:a-sub])\n          (subs/subscribe [:b-sub])])\n       (fn [[a b] [_]] {:a a :b b}))\n\n  Two functions provided. The 2nd is computation function, as before. The 1st\n  is returns what `input signals` should be provided to the computation. The\n  `input signals` function is called with two arguments: the query vector\n  and the dynamic vector. The return value can be singleton reaction or\n  a sequence of reactions.\n\n  3. (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] [_]] {:a a :b b}))```\n  This 3rd variation is just syntactic sugar for the 2nd. Pairs are supplied instead\n  of an `input signals` functions. `:<-` is supplied followed by the subscription\n  vector.\n  ","^1>",["^ ","^12",true,"^16",1,"^13",[["^X",["^1;","^1A"]]],"^W",["^X",[["^1;","~$&","^1A"]]],"^15",["^X",[null]]]],"^?","~$re-frame.subs/reg-sub","^12",true,"^R","test-compiled/re_frame/subs.cljc","^V",14,"^1>",["^ ","^12",true,"^16",1,"^13",[["^X",["^1;","^1A"]]],"^W",["^X",[["^1;","~$&","^1A"]]],"^15",["^X",[null]]],"^13",[["^X",["^1;","^1A"]]],"^14",null,"^15",["^X",[null]],"^T",1,"^S",137,"^U",137,"^16",1,"^17",true,"^W",["^X",[["^1;","~$&","^1A"]]],"^10","Associate the given `query id` with a handler function and an optional signal function.\n\n  There's 3 ways this function can be called\n\n  1. (reg-sub\n       :test-sub\n       (fn [db [_]] db))\n  The value in app-db is passed to the computation function as the 1st argument.\n\n  2. (reg-sub\n       :a-b-sub\n       (fn [q-vec d-vec]\n         [(subs/subscribe [:a-sub])\n          (subs/subscribe [:b-sub])])\n       (fn [[a b] [_]] {:a a :b b}))\n\n  Two functions provided. The 2nd is computation function, as before. The 1st\n  is returns what `input signals` should be provided to the computation. The\n  `input signals` function is called with two arguments: the query vector\n  and the dynamic vector. The return value can be singleton reaction or\n  a sequence of reactions.\n\n  3. (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] [_]] {:a a :b b}))```\n  This 3rd variation is just syntactic sugar for the 2nd. Pairs are supplied instead\n  of an `input signals` functions. `:<-` is supplied followed by the subscription\n  vector.\n  "],"~$query->reaction",["^ ","^?","~$re-frame.subs/query->reaction","^R","test-compiled/re_frame/subs.cljc","^S",18,"^T",1,"^U",18,"^V",21,"^Q",["^ ","^R","/Users/matus/www/district0x/contribution/test-compiled/re_frame/subs.cljc","^S",18,"^T",6,"^U",18,"^V",21]],"~$clear-all-handlers!",["^ ","^P",null,"^Q",["^ ","^R","/Users/matus/www/district0x/contribution/test-compiled/re_frame/subs.cljc","^S",38,"^T",7,"^U",38,"^V",26,"^W",["^X",["^Y",["^X",[[]]]]],"^10","Unregisters all existing subscription handlers"],"^?","~$re-frame.subs/clear-all-handlers!","^12",false,"^R","test-compiled/re_frame/subs.cljc","^V",26,"^13",["^X",[[]]],"^14",null,"^15",["^X",[null,null]],"^T",1,"^S",38,"^U",38,"^16",0,"^17",true,"^W",["^X",["^Y",["^X",[[]]]]],"^10","Unregisters all existing subscription handlers"],"~$cache-lookup",["^ ","^P",null,"^Q",["^ ","^R","/Users/matus/www/district0x/contribution/test-compiled/re_frame/subs.cljc","^S",60,"^T",7,"^U",60,"^V",19,"^W",["^X",["^Y",["^X",[["^Z"],["^Z","~$dyn-v"]]]]],"^1>",["^ ","^12",false,"^16",2,"^13",["^X",[["^Z"],["^Z","^1H"]]],"^W",["^X",[["^Z"],["^Z","^1H"]]],"^15",["^X",[null,null]]]],"^?","~$re-frame.subs/cache-lookup","^12",false,"^R","test-compiled/re_frame/subs.cljc","^V",19,"^1>",["^ ","^12",false,"^16",2,"^13",["^X",[["^Z"],["^Z","^1H"]]],"^W",["^X",[["^Z"],["^Z","^1H"]]],"^15",["^X",[null,null]]],"^13",["^X",[["^Z"],["^Z","^1H"]]],"^14",null,"^15",["^X",[null,null]],"^T",1,"^S",60,"^U",60,"^16",2,"^17",true,"^W",["^X",[["^Z"],["^Z","^1H"]]]],"~$map-vals",["^ ","^P",null,"^Q",["^ ","^R","/Users/matus/www/district0x/contribution/test-compiled/re_frame/subs.cljc","^S",117,"^T",8,"^U",117,"^V",16,"^19",true,"^W",["^X",["^Y",["^X",[["~$f","~$m"]]]]],"^10","Returns a new version of 'm' in which 'f' has been applied to each value.\n  (map-vals inc {:a 4, :b 2}) => {:a 5, :b 3}"],"^19",true,"^?","~$re-frame.subs/map-vals","^12",false,"^R","test-compiled/re_frame/subs.cljc","^V",16,"^13",["^X",[["~$f","~$m"]]],"^14",null,"^15",["^X",[null,null]],"^T",1,"^S",117,"^U",117,"^16",2,"^17",true,"^W",["^X",["^Y",["^X",[["~$f","~$m"]]]]],"^10","Returns a new version of 'm' in which 'f' has been applied to each value.\n  (map-vals inc {:a 4, :b 2}) => {:a 5, :b 3}"],"~$kind",["^ ","^?","~$re-frame.subs/kind","^R","test-compiled/re_frame/subs.cljc","^S",10,"^T",1,"^U",10,"^V",10,"^Q",["^ ","^R","/Users/matus/www/district0x/contribution/test-compiled/re_frame/subs.cljc","^S",10,"^T",6,"^U",10,"^V",10]],"~$clear-subscription-cache!",["^ ","^P",null,"^Q",["^ ","^R","/Users/matus/www/district0x/contribution/test-compiled/re_frame/subs.cljc","^S",20,"^T",7,"^U",20,"^V",32,"^W",["^X",["^Y",["^X",[[]]]]],"^10","Runs on-dispose for all subscriptions we have in the subscription cache.\n  Used to force recreation of new subscriptions. Should only be necessary\n  in development.\n\n  The on-dispose functions for the subscriptions will remove themselves from the\n  cache.\n\n  Useful when reloading Figwheel code after a React exception, as React components\n  aren't cleaned up properly. This means a subscription's on-dispose function isn't\n  run when the components are destroyed. If a bad subscription caused your exception,\n  then you can't fix it without reloading your browser."],"^?","~$re-frame.subs/clear-subscription-cache!","^12",false,"^R","test-compiled/re_frame/subs.cljc","^V",32,"^13",["^X",[[]]],"^14",null,"^15",["^X",[null,null]],"^T",1,"^S",20,"^U",20,"^16",0,"^17",true,"^W",["^X",["^Y",["^X",[[]]]]],"^10","Runs on-dispose for all subscriptions we have in the subscription cache.\n  Used to force recreation of new subscriptions. Should only be necessary\n  in development.\n\n  The on-dispose functions for the subscriptions will remove themselves from the\n  cache.\n\n  Useful when reloading Figwheel code after a React exception, as React components\n  aren't cleaned up properly. This means a subscription's on-dispose function isn't\n  run when the components are destroyed. If a bad subscription caused your exception,\n  then you can't fix it without reloading your browser."]],"~:require-macros",["^ ","^F","^G","^G","^G"],"~:cljs.analyzer/constants",["^ ","~:seen",["^>",["~:dyn-v","~:tags","~:sub/run","~:else","~:<-","~:sub","~:sub/create","~:warn","~:operation","~:start","~:duration","~:query-v","~:cached?","~:sub/dispose","~:error","~:input-signals","~:end","~:reaction","~:op-type"]],"~:order",["^1X","^1Z","^1[","^29","^1T","^24","^22","^28","^20","^25","^1V","^21","^27","^1Y","^23","^1S","^26","^1W","^1U"]],"^10",null]